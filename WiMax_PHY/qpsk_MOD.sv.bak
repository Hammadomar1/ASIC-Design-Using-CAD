// QPSK modulator block RTL design
// Done by: ASIC team 4
// ASIC PROJECT



module qpsk_MOD (
    input logic clk_50,           // 50 MHz input clock
    input logic clk_100,          // 100 MHz output clock (generated by PLL)
    input logic Reset_N,          // Active-low reset
    input logic data_in,          // Serial input data (1 bit at a time)
    input logic valid_interleaver, // Valid input from interleaver -->
    input logic ready_TOP_TB,   // input coming from top module test bench <--
    output logic ready_interleaver, // output ready to interleaver <--
    output logic valid_TOP_TB, // output going to top module test bench -->
    output logic signed [15:0] I_comp, // I-component (16 bits for each symbol)
    output logic signed [15:0] Q_comp  // Q-component (16 bits for each symbol)
);

    // QPSK Constellation points in Q15 format
    localparam logic signed [15:0] POS_A = 16'd23170; // 0.707 in Q15 format
    localparam logic signed [15:0] NEG_A = -16'd23170; // -0.707 in Q15 format

    // Internal signals
    logic [1:0] symbol; // Temporary 2-bit symbol register to work on 2 bits at a time - 00 / 01 / 10 / 11
    bit  bit_count;  // Bit counter for 2 bit symbol [either 0/1]

    always_ff @(posedge clk_100 or negedge Reset_N) begin
        if (Reset_N == 1'b0) begin // if Reset N = 0 (active low)
            // I_comp <= 16'd0; // dis-assert I component
            // Q_comp <= 16'd1; // dis-assert Q component
           // symbol <= 2'b00; // make symbol zero
            bit_count <= 0; // dis-assert counter
            valid_TOP_TB <= 0; // cannot send valid to top module
            ready_interleaver <= 0; // cannot send ready to interleaver
        end else begin
            // Shift in serial bits to form a 2-bit symbol
             if(valid_interleaver == 1'b1) begin // the data coming from interleaver is correct -- test bench
            symbol[bit_count] <= data_in; // make symbol[counter] be the serial data in
            bit_count <= bit_count + 1; // increment counter to take in the next serial bit
            // Once we have 2 bits, determine I and Q components
            if (bit_count == 1) begin // if bit count = 1, this means we already have the 2 bits to work on
                case (symbol)
                    2'b00: begin I_comp <= POS_A; Q_comp <= POS_A; end // 00 -> (+0.707, +0.707)
                    2'b01: begin I_comp <= POS_A; Q_comp <= NEG_A; end // 01 -> (+0.707, -0.707)
                    2'b10: begin I_comp <= NEG_A; Q_comp <= POS_A; end // 10 -> (-0.707, +0.707)
                    2'b11: begin I_comp <= NEG_A; Q_comp <= NEG_A; end // 11 -> (-0.707, -0.707)
                  //  default: begin I_comp <= POS_A; Q_comp <= NEG_A; end
                endcase
                
                // if (symbol == {I_comp[15], Q_comp[15]}) begin
                //     valid_TOP_TB <= 1'b1; // Set valid if match
                // end else begin
                //     valid_TOP_TB <= 1'b0; // Clear valid if no match
                // end
                // bit_count <= 0;  // Reset bit counter for the next symbol (to work on the next 2 bits)
            end

        end
        end
    end
endmodule